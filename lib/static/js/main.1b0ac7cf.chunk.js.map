{"version":3,"sources":["lib/index.tsx"],"names":["MODULE_COMMON","js_meta_types","_initStore","testLoadingFn","tag","console","log","reaction","store","Object","create","showLoading","hideLoading","defaultMaxProcessSeconds","reducer","state","act","module","copy","moduleStore","assign","payload","warn","actionQueue","doAction","moduleAction","loadingTag","mAction","process","Error","canStartAction","useLoading","push","action","name","a","undefined","length","nextAction","doFunction","fn","globalState","getState","moduleState","data","maxTime","maxProcessSeconds","Promise","resolve","tmHdl","setTimeout","error","then","_","finally","clearTimeout","processData","dispatch","type","dir","shift","mapProp","props","moduleName","hasOwnProperty","regStore","target","mappedFlag","__mappedMd__","includes","connect","st","mdStore","forEach","key","uiKey","mdKey","kv","split","mdNm","createStore","enableDevtools","enhancer","win","window","__REDUX_DEVTOOLS_EXTENSION__","getGlobalState","getModuleState","getModuleProp","propName","Pr","this","children","React","Component"],"mappings":"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","file":"static/js/main.1b0ac7cf.chunk.js","sourcesContent":["import React from 'react';\nimport { connect, Provider as RdProvider } from 'react-redux';\nimport { createStore, Store } from 'redux';\n// defines -------------------------------------------------------------\nexport const MODULE_COMMON = 'reaction_module_common';\n\nexport interface KV {\n    [k: string]: any\n}\n\nexport interface ModuleStore extends KV {\n    module: string;\n}\n\n/**\n * \n * 如果process里想拿到全局store或其他模块store,可调用：getGlobalState或getModuleState ！！！\n */\nexport interface ModuleAction<PAYLOAD_TYPE = any, MODULE_STORE = ModuleStore, PROCEED_RESULT = KV> {\n    /** the relative module this action will modify */\n    module: string;\n\n    /** the action's name, by default will be 'moduleAction'*/\n    name?: string;\n\n    /** the max time(by seconds) allowed the process functiion execute, if timeout, the process will be cancel and return a blank {}  */\n    maxProcessSeconds?: number;\n\n    /** the business logic processor, normally, you can fetch apis, do sth complex, etc.\n     * when finished your logic, please return the data to modify via k-v like, actually, you can\n     * only modify the specific moduleStore's props which you indicates by the 'module' property\n     * eg. there's a moduleStore holding the user info: \n     *      const userStore: ModuleStore = {module:'user', username: '', level: 0};\n     * then there's an action to fetch userInfo:\n     *      const getUserInfoAction: ModuleAction = {\n     *          module: 'user',\n     *          process: async (payload: KV, moduleStore: any) => {\n     *              const res = await someFetchMethod(payload.username, payload.password);\n     *              // when got the user info by server, return infos you wanna modify\n     *              return { level: res.level}\n     *          }\n     *      }\n     * \n     * PS: in process function, you can call 'getGlobalState ro getModuleState or getModuleProp' to get\n     * global/other module's store prop\n     */\n    process?: (payload: PAYLOAD_TYPE, moduleStore: MODULE_STORE) => Promise<PROCEED_RESULT>;\n}\n/// ---------------------------------------------------------------------\n\n// redux wrap------------------------------------------------------------\nconst js_meta_types = [\n    'bigint',\n    'boolean',\n    'string',\n    'number',\n    'function',\n    'symbol',\n    'undefined'\n]\nconst _initStore: KV = {};\ninterface ReactionDb {\n    store: Store; // the combined store of redux\n    showLoading: (loadingTag?: string) => void; // the showLoading function\n    hideLoading: (loadingTag?: string) => void; // the hideLoading function\n    defaultMaxProcessSeconds: number; // the default max time(by seconds) of one action's process\n}\nconst testLoadingFn = tag => console.log(`\ngot a loading tag: ${tag}, \nyou'd better implements your own 'showLoading' and 'hideLoading' \nby set reaction.showLoading/hideLoading property`\n);\n\nexport const reaction: ReactionDb = {\n    store: Object.create({}),\n    showLoading: testLoadingFn,\n    hideLoading: testLoadingFn,\n    defaultMaxProcessSeconds: 8 // by default, one action's process function is allow to execute 8s\n};\n\nconst reducer = (state: any, act: any) => {\n    if (act.module) {\n        let copy = { ...state };\n        // deal with data via module\n        const moduleStore = copy[act.module];\n        if (moduleStore) {\n            copy[act.module] = Object.assign(moduleStore, act.payload);\n        } else if (act.payload) {\n            // danger! treat the payload as a global data if there's no module id\n            copy = Object.assign(copy, act.payload);\n            console.warn(`you have produced a redux action without the 'module' id, which may cause error!`)\n        }\n        return copy;\n\n    }\n\n    return state;\n};\n\n// tslint:disable-next-line:interface-name\ninterface ActionNode<P = KV> {\n    action: ModuleAction;\n    payload: P;\n}\n\nconst actionQueue: ActionNode<any>[] = [];\n/**\n * execute an action\n *  specially ,if the first param was given a moduleName string, meanwile the payload is k-v data, \n * the freamework will simply merge the payload to the moduleStore of the moduleName\n * @param moduleAction action instance or moduleName\n * @param payload this data will be passed to action's process method，typically , it's a k-v data, eg: {a: 1, b: 'xx'}. if you give a simple metadata type (such as string, number, boolean...), the moduleAction must has a process method to deal with it\n * @param loading whether call showloading when execute this action\n */\nexport function doAction<P = KV>(\n    moduleAction: ModuleAction | string,\n    payload?: P,\n    loadingTag: string | 'none' = 'none'\n) {\n    let mAction: ModuleAction = typeof moduleAction === 'string' ?\n        { module: moduleAction } : moduleAction;\n\n    // rules: payload must be a KV type when there's no process function in given moduleAction\n    if (!mAction.process && typeof payload in js_meta_types) {\n        throw new Error(`\n        payload must be a KV type when there's no process function in given moduleAction!\n        when call 'doAction',\n        the param 'payload' is promoted to be a KV type,\n        if you really want to use js simple meta type data, you must declare a 'process' function in\n        the ModuleAction to deal with the payload and return a KV data\n        `)\n    }\n\n    let canStartAction = 1;\n    const useLoading = loadingTag !== 'none';\n    if (useLoading) {\n        // insert showloading\n        actionQueue.push({\n            action: {\n                name: `@@begin loading:${mAction.name}`,\n                module: MODULE_COMMON,\n                process: async () => {\n                    // call showLoading\n                    reaction.showLoading();\n                    // set the loadingTag of common module\n                    return { loadingTag };\n                }\n            },\n            payload: undefined\n        });\n    }\n    actionQueue.push({ action: mAction, payload });\n    if (useLoading) {\n        // insert hideloading\n        actionQueue.push({\n            action: {\n                name: `@@end loading:${mAction.name}`,\n                module: MODULE_COMMON,\n                process: async () => {\n                    // call hideLoading\n                    reaction.hideLoading();\n                    // reset the loadingTag of common module\n                    return { loadingTag: 'none' };\n                }\n            },\n            payload: undefined\n        });\n        canStartAction = 3;\n    }\n\n    if (actionQueue.length === canStartAction) {\n        nextAction();\n    }\n}\n\nexport function doFunction(fn: () => Promise<any>, payload?: KV) {\n    const action = {\n        module: 'none',\n        process: fn\n    };\n    doAction(action, payload);\n}\n\nasync function nextAction() {\n    if (!actionQueue.length) {\n        return;\n    }\n    const { action, payload } = actionQueue[0];\n    const globalState = reaction.store.getState();\n    const moduleState = globalState[action.module];\n    try {\n        const data = payload; // moduleAction如果不提供process函数，就认为payload无需处理\n        let processData;\n        if (action.process) {\n            const maxTime = (action.maxProcessSeconds || reaction.defaultMaxProcessSeconds) * 1000;\n\n            processData = await new Promise(resolve => {\n                const tmHdl = setTimeout(() => {\n                    console.error(`action:[module:${action.module},name:${action.name}] 's process timeout! `);\n                    resolve({}); // return a blank obj\n                }, maxTime);\n                action.process!(payload, moduleState).then(_ => resolve(_)).finally(() => clearTimeout(tmHdl));\n            })\n\n        }\n        // dispatch a redux's action to merge data\n        reaction.store.dispatch({\n            type: action.name || 'moduleAction',\n            module: action.module,\n            payload: processData || data\n        });\n    } catch (ex) {\n        console.dir(ex);\n    }\n\n    actionQueue.shift();\n\n    if (actionQueue.length > 0) {\n        nextAction();\n    }\n}\n\n/**\n * the decorator used to inject moduleStore's props to Compnent\n * you can use this decorator several times to inject different moduleStore's props, eg. mapProp(moduleA, 'a','b') mapProp(moduleB, 'c','d')\n * while, you can not use it twice or more when inject one same moduleStore. in other words, mapProp(moduleA, 'a','b') mapProp(moduleA, 'c', 'd') will course error, instead, use mapProp(moduleA, 'a','b','c','d') to inject all props you need in one call\n * \n * @param moduleStore the moduleStore or the moduleName you wanna inject from.\n * here receive two types of para\n *  1. string, indicates the moduleName, make sure you have called the 'regStore' mannaully before\n *  2. moduleStore instance, then in this mapProp function, will call 'regStore' automaticly by using the [copy] of the moduleStore given only if moduleStore.module not registered before!!(so one module will not be registered twice or more)\n * @param props these propNames of the moduleStore you wanna inject, \n * here're two syntax sugars:\n *  1.if you want to inject all the props of the moduleStore, you can bypass the props param(feel free to let this param blank)\n *  2.you can rename props by use a ':', eg. mapProp(moduleA, 'a','b:bbb'), then in the Component, this.props.bbb refers to the moduleA.b 's value\n * \n */\nexport function mapProp(module: ModuleStore | string, ...props: string[]): Function {\n    let moduleName: string;\n    if ( typeof module === 'string' ) {\n        moduleName = module;\n    } else {\n        moduleName = module.module;\n        if (!_initStore.hasOwnProperty(moduleName)) {\n            // reg the moduleStore if it has not\n            // make a copy when call regStore, so you may reset the moduleStore's prop to initial state by\n            // simply doAction({module: 'xxModule'}, xxModuleStore)\n            regStore({ ...module });\n        }\n    }\n    return function (target: any) {\n        let mappedFlag: string = target.__mappedMd__ || '';\n        if (mappedFlag && mappedFlag.includes(moduleName)) {\n            return target;\n        } else {\n            mappedFlag += '_' + moduleName;\n            target.__mappedMd__ = mappedFlag;\n\n            return connect((state: KV) => {\n                let st: KV = {};\n                if (props.length > 0) {\n                    const mdStore = state[moduleName];\n                    props.forEach(key => {\n                        if (mdStore) {\n                            let uiKey, mdKey;\n                            if (key.includes(':')) {\n                                const kv = key.split(':');\n                                uiKey = kv[0];\n                                mdKey = kv[1];\n                            } else {\n                                uiKey = mdKey = key;\n                            }\n                            st[uiKey] = mdStore[mdKey];\n                        } else {\n                            throw new Error('please inject module-store to global by call regStore() first of all.');\n                        }\n                    });\n                } else {\n                    const mdStore = state[moduleName];\n                    st = { ...mdStore };\n                }\n                return st;\n            })(target);\n        }\n\n    };\n}\n\nexport function regStore(moduleStore: ModuleStore) {\n    const mdNm = moduleStore.module;\n    _initStore[mdNm] = moduleStore;\n    Object.assign(reaction.store, createStore(reducer, _initStore));\n}\n\nexport function enableDevtools() {\n    let enhancer;\n    const win: KV = window;\n    if (win.__REDUX_DEVTOOLS_EXTENSION__) {\n        enhancer = win.__REDUX_DEVTOOLS_EXTENSION__();\n    }\n    Object.assign(reaction.store, createStore(reducer, _initStore, enhancer));\n}\n\n// return the global store's snapshot state\nexport function getGlobalState() {\n    return reaction.store.getState();\n}\n\n// return the specific moduleStore's snapshot state\nexport function getModuleState<T>(moduleName: string): T | any {\n    return getGlobalState()[moduleName] as T;\n}\n\n// return the specific moduleStore's prop by name\nexport function getModuleProp(moduleName: string, propName: string): any {\n    const mdStore = getModuleState(moduleName);\n    return mdStore ? mdStore[propName] : null;\n}\n\nexport class Pr extends React.Component<{},{}>{\n    render() {\n        return <RdProvider store={reaction.store}>{this.props.children}</RdProvider>\n    }\n}"],"sourceRoot":""}